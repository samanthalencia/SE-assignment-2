[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15244377&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering: Software engineering is the application of engineering principles and techniques design, develop, testing and maintenance of software systems. It involves a systematic approach to creating software emphasizing a structured process. Software engineering involves a structured process that includes requirement gathering, design, implementation, testing and maintenance whereas traditional programming often lacks a formal process. Software engineering applies scientific and mathematical principles to the design, analysis and implementation of software systems. 

What is software engineering, and how does it differ from traditional programming?
oftware engineering is a systematic approach to the development, operation, and maintenance of software. It involves applying engineering principles to software development, focusing on the entire software development life cycle, including requirements, design, construction, testing, maintenance, and management.

Differences:
Scope: Software engineering encompasses the entire software development process, including planning, design, testing, and maintenance, while traditional programming typically focuses on writing code to solve specific problems.
Methodology: Software engineering emphasizes the use of systematic and disciplined approaches to software development, such as Agile, Waterfall, or DevOps, while traditional programming may involve ad-hoc or informal coding practices.
Quality Assurance: Software engineering places a strong emphasis on quality assurance, including testing, debugging, and maintenance, to ensure the reliability and robustness of the software, whereas traditional programming may have a narrower focus on writing code without as much emphasis on comprehensive testing and maintenance.
Team Collaboration: Software engineering often involves collaboration among multidisciplinary teams, including developers, testers, project managers, and stakeholders, while traditional programming may be more individual-focused.

Software Development Life Cycle (SDLC):

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

Planning phase
This is the initial stage of software development, which involves defining the software's purpose and scope. The team collaborates to understand the project scope, identify stakeholders, users and their requirements, project timeline, budget and resources. Essentially, the teams asks questions like " what problem will this software solve?" and "what value will it offer to the users?". The planning phase fosters effect communication and collaboration within the team.

Requirements gathering and analysis phase
This phase seeks to identify and record the precise requirements of the final users. They make use of techniques like interviews, surveys and case studies. The team is looking to answer question like , for an example, " what are the expectations of our users from our software?". The process involves not only asking the right questions, but also accurately interpreting the responses accurately. After analysis, the team distinguishes the essential features from the desirable ones, this is so they can understand the software's functionality, performance, security and interface needs. This phase's success is pivotal for the entire project.

Design phase
This phase is all about building the framework. The development team is responsible for software engineering outlines the software functionality and aesthetic. The team develops a detailed design based on the requirements. They create data models and interface prototypes, and define the system architecture. This phase ensures that the software is user friendly and performs its tasks efficiently. 

Implementation phase
In this phase, software engineers and developers get down to business and start converting the software design into tangible code. The phase's aim is to develop a software that is functional, efficient and user-friendly. Developers use an appropriate programming language to write the code. Team members carefully examine each and every other's work to identify bugs. At the end of this phase, a functional piece of software comes to life

Testing phase
This face takes place to verify that the software meets all the requirements and works as expected. The team conducts various types of testing ( unit testing, integration testing, system testing and acceptance testing). The aim is to ensure flawless software operation before it reaches the end-user, and to identify opportunity fore enhancements. This includes identifying the necessary software conditions and outlining diverse scenarios to examine the conditions. The developers and engineers should rigorously test the software,. When the test reveals a bug, it is documented in detail and sent back to developers for rectification.

Deployment phase 
This phase involves rolling out the meticulously tested and fine-tuned software to the end-users. This is where the team conducts final testing and quality assurance. Depending on the software and its audience, the team might use different methods to ensure minimal disruptions to the use-experience, methods such as big-bang or canary deployment. This phase shows the shift from project design, where the software begins to fulfil its purpose.

Maintenance phase
This phase is where the team monitors and support the software in production. They fix the defects and issues reported by end-users, implement updates, enhancements and add new features. They continuously improve the software based on use-feedback and changing requirements. Maintenance phase is a continuous process of refining and adapting, like a gardener tending to their garden.

Agile vs. Waterfall Models:

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?

Agile model is a flexible approach that emphasizes collaboration, continuous improvement and rapid delivery. While waterfall is a linear and structured approach that follows a sequential phase-by-phase progression. 
Agile methodologies are about teamwork, customer satisfaction, constant refinement and breaking big projects into to bite-sized pieces. While, waterfall methodology includes the five project management stages: initiation, planning, execution, monitoring and closing. White this Approach is effective for straightforward projects that require minimal creativity or adaption, it may not be suitable for complex initiatives that demand a more flexible and dynamic approach.
 It is easy to track progress, identify risks and manage budgets when using waterfall methodology. White is takes a loner delivery timeline and slow time to market when using the agile methodology.

In what scenarios might each be preferred? 

Waterfall methodologies best suits we-defined projects with clearly specified requirements, limited complexity and a definitive timeline. It works well when the customer's demands are precise and when there are no significant changes in scope or technology during the project. The waterfall model fits projects with a simple scope and requirement gathering, clear and linear sequence of tasks, predictable deliverables based on set timelines, structured process and rigid quality control measures.(float.com)

Agile methodology is a good fit in cases where the end goal may be unclear or difficult to define, when complex systems require frequent feedback loops or when the timeline and budgets are tight. It is also effective for developing software applications since it allows for quick iteration and testing along the way. Moreover, agile can helpful when dealing with teams who need to collaborate intensively, such as those located in different location. Agile method can be an excellent fit for many teams and projects, especially those that require complex deliverable, emergent requirements and multiple stakeholders.

Requirements Engineering:

What is requirements engineering? 

The area of systems engineering that deals with the process developing and verifying the system requiring. It helps achieve the primary objective of making sure that the delivered system meets the customer's needs. Requirements engineering is the process of defining, documenting, and maintaining requirements. It involves activities like elicitation, analysis, specification, and verification to ensure software meets stakeholders’ needs. Proper management improves project clarity, reduces errors, and aligns expectations.

Describe the process and its importance in the software development lifecycle.

Requirements engineering is a tool for regulating processes in software development life cycles:  It’s not only crucial at the beginning of a project, when specifications are usually first created, but throughout all stages as projects often require changes or new specifications while development is in progress. Engineering and managing requirements are key processes to maintain control over a project and ensure coherence across the board. 

Project management: Correctly defined and documented requirements enable team members to establish clear project goals and scope. They also help avoid miscommunication and ensure that all stakeholders are in alignment on their expectations regarding the solution in development.

Coding: When working with vague or incomplete specifications, engineers have to rely on assumptions, which may lead to mistakes. Well-defined requirements inform developers about how a system should work. They help developers effectively plan, design and implement software that meets clients’ and users’ expectations. Requirements engineering also detects any contradictions and discrepancies in a solution. 

Testing: Among its many other functions, software testing aims to verify if a system meets specific requirements. Requirements serve as a basis for creating test cases and scenarios to run effective tests. Unclear, incomplete or contradictory requirements make the testers’ job much more difficult. For example, vague acceptance criteria can often result in a misinterpretation of functionality descriptions. (KAMIL JĘDRZEJKO,2023)

Software Design Principles:

Explain the concept of modularity in software design. 

Modularity in computing and programming refers to dividing a system into separate modules or components. Each module handles a specific functionality and operates independently. In software design, modularity refers to a logical partitioning of the "software design" that allows complex software to be manageable for the purpose of implementation and maintenance. The logic of partitioning may be based on related functions, implementation considerations, data links, or other criteria

How does it improve maintainability and scalability of software systems?

Modularity plays a crucial role in enhancing the maintainability and scalability of software systems. By employing software modularization techniques, such as search-based optimization, clustering algorithms, and hierarchical clustering approaches, developers can extract subsystems, improve system comprehension, and re-modularize source code structures . These techniques facilitate a better understanding of system architectures, aid in software maintenance actions like refactoring, and support collaborative development efforts, especially in addressing security concerns in distributed software systems 

Modularity enables the creation of well-defined components, clusters, and modules, which not only enhance readability and reusability but also allow for easier scalability as systems evolve and grow in complexity, ultimately leading to more manageable and sustainable software systems over time.If implemented correctly, modularity can enhance security. By isolating functionalities into separate modules, you limit the exposure of different parts of your system. If a vulnerability is found in one module, it is less likely to impact others, containing potential risks.

Testing in Software Engineering:

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing).

Unit testing
This is the first step of testing that is completed by developers whereby they test as each component is completed. Software testing helps ensure code quality, and it's an integral part of software development. It's a software development best practice to write software as small, functional units then write a unit test for each code unit

Integration testing
This is whereby developers pull components together and test as a large unit. They do so to find problems/ bugs in how the components work together, this is a common phase for project failure. They test technical requirements of how the components are supposed to work. 

System testing
This is the last chance for the project team to verify the software and validate if the software meets business requirements. It includes many different types of tests as testing functional requirements, this is where they test how the software is meant to function.

Acceptance testing
This is the final phase of testing where users utilize real-life scenarios to verify that the software meets their needs. Users are the main testers, not the project team. Acceptance testing can reduce the risk of customer dissatisfaction and costly recalls, it focuses on mitigating risks associated with software deployment and usage in a real-world environment. (Udemy.com)


Why is testing crucial in software development?

Identifies defects early
 Developing complex applications can leave room for errors. Software testing is imperative, as it identifies any issues and defects with the written code so they can be fixed before the software product is delivered. 
 
Improves product quality
 When it comes to customer appeal, delivering a quality product is an important metric to consider. An exceptional product can only be delivered if it's tested effectively before launch. Software testing helps the product pass quality assurance and meet the criteria and specifications defined by the users.

Increases customer trust and satisfaction
Testing a product throughout its development lifecycle builds customer trust and satisfaction, as it provides visibility into the product's strong and weak points. By the time customers receive the product, it has been tried and tested multiple times and delivers on quality.

Detects security vulnerabilities
Insecure application code can leave vulnerabilities that attackers can exploit. Since most applications are online today, they can be a leading vector for cyber attacks and should be tested thoroughly during various stages of application development. For example, a web application published without proper software testing can easily fall victim to a cross-site scripting attack where the attackers try to inject malicious code into the user's web browser by gaining access through the vulnerable web application. The non-tested application thus becomes the vehicle for delivering the malicious code, which could have been prevented with proper software testing.

Helps with scalability
A type of nonfunctional software testing process, scalability testing is done to gauge how well an application scales with increasing workloads, such as user traffic, data volume and transaction counts. It can also identify the point where an application might stop functioning and the reasons behind it, which may include meeting or exceeding a certain threshold, such as the total number of concurrent app users.

Saves money
Software development issues that go unnoticed due to a lack of software testing can haunt organizations later with a bigger price tag. After the application launches, it can be more difficult to trace and resolve the issues, as software patching is generally more expensive than testing during the development stages. (ww.techtarget.com)

Version Control Systems:

What are version control systems, and why are they important in software development? 

VCS also known as source control or revision control, is an important software development practice for tracking and managing changes made to code and other files. It is closely related to source code management. A version control system tracks every alteration to a file or set of files, enabling developers to journey back to earlier versions and collaborate seamlessly. Centralized version control systems  streamline this process by housing all file versions on a single server. Developers borrow a file to tweak, then return it with updates, all neatly stored and cataloged by the server. This method shines in its simplicity, offering a straightforward path for managing changes.

Version control encourages a culture of continuous peer review and collaboration, leading to significant improvements in code quality. By facilitating detailed tracking of every change, teams can easily review, comment, and refine their work, ensuring adherence to best practices and standards. This collaborative scrutiny not only elevates the quality of the output but also aids in early bug detection and resolution.

Version control systems streamline development processes, enabling faster iteration and delivery of features. Efficient branching and merging capabilities allow developers to work concurrently on various aspects of a project without interference, significantly reducing the time from development to deployment. Additionally, the ability to quickly revert to previous versions minimizes downtime when addressing issues, keeping the project momentum steady.

 A central repository in a version control system acts as the single source of truth, enhancing project transparency and accountability. This centralized view of the project's evolution aids in better planning, tracking, and collaboration, as every team member has access to the latest updates and historical changes. The integration with project management tools further bolsters project oversight, linking code changes directly to tasks and milestones.(gitlab.com)

Give examples of popular version control systems and their features.

GitHub 
GitHub helps software teams to collaborate and maintain the entire history of code changes. You can track changes in code, turn back the clock to undo errors and share your efforts with other team members. It is a repository to host Git projects. For those wondering what is Git? It is an open source version control system that features local branching, multiple workflows, and convenient staging areas. Git version control is an easy to learn option and offers faster operation speed.

Microsoft Team Foundation Server
Developed by Microsoft, the Team Foundation Server is an enterprise-grade tool to manage source code and other services that need versioning. It can keep track of work items to find defects, requirements, and scenarios in a project. It comes with several unique features like Team Build, data collection and reporting, Team Project Portal, Team Foundation Shared Services, etc.

AWS CodeCommit
AWS CodeCommit is a managed version control system that hosts secure and scalable private Git repositories. It seamlessly connects with other products from Amazon Web Services (AWS) and hosts the code in secured AWS environments. Hence, it is a good fit for the existing users of AWS. AWS integration also provides access to several useful plugins from AWS partners, which helps in software development.

Software Project Management:

Discuss the role of a software project manager
A software project manager is the most important person inside a team who takes the overall responsibilities to manage the software projects and plays an important role in the successful completion of the projects.  Project planning is undertaken immediately after the feasibility study phase and before the starting of the requirement analysis and specification phase. Once a project is feasible, Software project managers start project planning. Project planning is completed before any development phase starts.

What are some key responsibilities and challenges faced in managing software projects?

 Project Estimation
Project Size Estimation is the most significant parameter based on which all other estimations like cost, duration and effort are made.
Cost Estimation: Total expenses to develop the software product is estimated.
Time Estimation: The total time required to complete the project.
Effort Estimation: The effort needed to complete the project is estimated.

Scheduling
After the completion of the estimation of all the project parameters, scheduling for manpower and other resources is done.

Staffing
Team structure and staffing plans are made.

 Risk Management
The project manager should identify the unanticipated risks that may occur during project development risk, analyze the damage that might cause these risks, and take a risk reduction plan to cope with these risks.

 Miscellaneous Plans
This includes making several other plans such as quality assurance plans, configuration management plans, etc.

Lead the team
The project manager must be a good leader who makes a team of different members of various skills and can complete their individual tasks. One of the key roles of a software project manager is to encourage team members to work properly for the successful completion of the project.

Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. 

Software maintenance is the process of changing, modifying, and updating software to keep up with customer needs. Software maintenance is done after the product has launched for several reasons including improving the software overall, correcting issues or bugs, to boost performance, and more. Software maintenance is a natural part of SDLC. Software developers don’t have the luxury of launching a product and letting it run, they constantly need to be on the lookout to both correct and improve their software to remain competitive and relevant.

The three types are:

Corrective Software Maintenance
Corrective software maintenance is the typical, classic form of maintenance (for software and anything else for that matter). Corrective software maintenance is necessary when something goes wrong in a piece of software including faults and errors. These can have a widespread impact on the functionality of the software in general and therefore must be addressed as quickly as possible. Many times, software vendors can address issues that require corrective maintenance due to bug reports that users send in. If a company can recognize and take care of faults before users discover them, this is an added advantage that will make your company seem more reputable and reliable.

Preventative Software Maintenance
Preventative software maintenance is looking into the future so that your software can keep working as desired for as long as possible. This includes making necessary changes, upgrades, adaptations and more. Preventative software maintenance may address small issues which at the given time may lack significance but may turn into larger problems in the future. These are called latent faults which need to be detected and corrected to make sure that they won’t turn into effective faults. 

Perfective Software Maintenance
As with any product on the market, once the software is released to the public, new issues and ideas come to the surface. Users may see the need for new features or requirements that they would like to see in the software to make it the best tool available for their needs. This is when perfective software maintenance comes into play. Perfective software maintenance aims to adjust software by adding new features as necessary and removing features that are irrelevant or not effective in the given software. This process keeps software relevant as the market, and user needs, change. 

Why is maintenance an essential part of the software lifecycle?

Software applications need to perform optimally to meet user expectations. Over time, as new features are added and data accumulates, the performance of software may degrade. Maintenance activities such as code optimization, database tuning, and performance monitoring help identify bottlenecks and fine-tune the software application for optimal performance.By ensuring efficient computing resource utilization and minimizing response times, businesses can provide a seamless user experience and competitive edge in any industry. 

The software landscape is in a constant state of evolution, with new operating systems, hardware configurations, and dependencies introduced regularly. Without the proper software maintenance process, software applications can fall out of sync with the latest technologies, resulting in compatibility issues. That’s where regular updates and compatibility testing come into play. By staying proactive and conducting thorough compatibility assessments, businesses can adapt to evolving environments. This ensures that their software products remain stable and usable across various platforms, devices, middleware updates, and other changes in versions of related software.

End-user feedback is invaluable for improving software applications. Users often encounter issues or suggest improvements that can enhance functionality or user experience. Software maintenance activities provide an opportunity to gather and analyze user feedback, incorporating valuable insights into future updates and releases. By addressing user needs and expectations, businesses can build stronger relationships with their customers and gain a competitive edge.

To ensure your software stands the test of time, embracing software maintenance becomes the key. Through regular updates and improvements, your software retains its relevance and value in an ever-evolving landscape. It adapts to emerging technologies, catering to the evolving needs of users. By embracing the practice of software maintenance, your software remains a formidable competitor, always one step ahead in the dynamic market.

Ethical Considerations in Software Engineering:

What are some ethical issues that software engineers might face?

software developers work primarily behind the scenes in businesses, their decisions in the course of a project can have an outsized impact in the world -- for better or worse. Everyone in the industry should be aware of social and ethical issues in software development. Here are five examples of ethical issues and how developers can address them:

Addictive design
The problem is that some teams craft apps that people love too much. There is an ethical concern about the role of digital platforms, such as social media.

corporate ownership of personal data
This ethical issue is a dilemma for developers in every kind of business -- not just the social media giants who make the news. An algorithm directs information collection and building a profile, but the subsequent actions are intentional, and the developer is ordinarily aware of the power of this data in context

Algorithmic bias
Software engineers can only learn from the training it is given. Therefore, developers and data scientists must scrub bias from the training data and the algorithms they build. From a developer's perspective, bias often centers on eliminating options for the wrong reasons. 

Weak cyber security and personally identifiable information (PII) protection
Developers often only address security after code release, rather than during development. As a result, the software community lacks secure development standards. "The emphasis is almost entirely on getting a product out to market," said Randolph Morris, CEO of Bit Developers, a software development consultancy. Once a software product is publicly available, the focus shifts to new features and performance optimization, so security continues to have minimal prominence. Hackers and other malicious actors cause real damage to real people. Our current digital ecosystem tends to address application security by plugging vulnerabilities as they are found.
 
Overemphasis on features
At the center of many ethical issues is a decision that capabilities in software releases are more important than the effects they could have. But just because you can doesn't mean you should."If the development team is measured on their rate of feature development, there's a high probability that the ethics of a given implementation might not be front of mind, either at the design or at the implementation phase," said Tim Mackey, principal security strategist at Synopsys Cyber Security Research Center. 

How can software engineers ensure they adhere to ethical standards in their work?

In software engineering, ethics play a crucial role in guiding the actions and decisions of professionals in this field.The software engineering code of ethics is fundamental to ensuring that software engineers adhere to standards and promote responsible behavior in their work. Software engineers must understand and adhere to ethical standards in this fast-paced environment.A software engineering code of ethics is a moral compass, guiding professionals to make responsible decisions and ensuring that the products and services they develop align with societal values and expectations.Software engineering is about writing code and creating solutions that positively impact society.Ethical considerations are crucial in this process, as they help software engineers navigate complex issues and make choices that prioritize the well-being of users and the broader communities.
